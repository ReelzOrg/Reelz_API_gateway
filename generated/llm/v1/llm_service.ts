// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: llm/v1/llm_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "llm.v1";

export enum FileStatus {
  FILE_STATUS_UNSPECIFIED = 0,
  FILE_STATUS_UPLOADING = 1,
  FILE_STATUS_QUEUED = 2,
  FILE_STATUS_PROCESSING = 3,
  FILE_STATUS_READY = 4,
  FILE_STATUS_FAILED = 5,
  UNRECOGNIZED = -1,
}

export function fileStatusFromJSON(object: any): FileStatus {
  switch (object) {
    case 0:
    case "FILE_STATUS_UNSPECIFIED":
      return FileStatus.FILE_STATUS_UNSPECIFIED;
    case 1:
    case "FILE_STATUS_UPLOADING":
      return FileStatus.FILE_STATUS_UPLOADING;
    case 2:
    case "FILE_STATUS_QUEUED":
      return FileStatus.FILE_STATUS_QUEUED;
    case 3:
    case "FILE_STATUS_PROCESSING":
      return FileStatus.FILE_STATUS_PROCESSING;
    case 4:
    case "FILE_STATUS_READY":
      return FileStatus.FILE_STATUS_READY;
    case 5:
    case "FILE_STATUS_FAILED":
      return FileStatus.FILE_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileStatus.UNRECOGNIZED;
  }
}

export function fileStatusToJSON(object: FileStatus): string {
  switch (object) {
    case FileStatus.FILE_STATUS_UNSPECIFIED:
      return "FILE_STATUS_UNSPECIFIED";
    case FileStatus.FILE_STATUS_UPLOADING:
      return "FILE_STATUS_UPLOADING";
    case FileStatus.FILE_STATUS_QUEUED:
      return "FILE_STATUS_QUEUED";
    case FileStatus.FILE_STATUS_PROCESSING:
      return "FILE_STATUS_PROCESSING";
    case FileStatus.FILE_STATUS_READY:
      return "FILE_STATUS_READY";
    case FileStatus.FILE_STATUS_FAILED:
      return "FILE_STATUS_FAILED";
    case FileStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FinishReason {
  FINISH_REASON_UNSPECIFIED = 0,
  FINISH_REASON_COMPLETED = 1,
  FINISH_REASON_CANCELLED = 2,
  FINISH_REASON_ERROR = 3,
  FINISH_REASON_CONTEXT_LENGTH_EXCEEDED = 4,
  UNRECOGNIZED = -1,
}

export function finishReasonFromJSON(object: any): FinishReason {
  switch (object) {
    case 0:
    case "FINISH_REASON_UNSPECIFIED":
      return FinishReason.FINISH_REASON_UNSPECIFIED;
    case 1:
    case "FINISH_REASON_COMPLETED":
      return FinishReason.FINISH_REASON_COMPLETED;
    case 2:
    case "FINISH_REASON_CANCELLED":
      return FinishReason.FINISH_REASON_CANCELLED;
    case 3:
    case "FINISH_REASON_ERROR":
      return FinishReason.FINISH_REASON_ERROR;
    case 4:
    case "FINISH_REASON_CONTEXT_LENGTH_EXCEEDED":
      return FinishReason.FINISH_REASON_CONTEXT_LENGTH_EXCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FinishReason.UNRECOGNIZED;
  }
}

export function finishReasonToJSON(object: FinishReason): string {
  switch (object) {
    case FinishReason.FINISH_REASON_UNSPECIFIED:
      return "FINISH_REASON_UNSPECIFIED";
    case FinishReason.FINISH_REASON_COMPLETED:
      return "FINISH_REASON_COMPLETED";
    case FinishReason.FINISH_REASON_CANCELLED:
      return "FINISH_REASON_CANCELLED";
    case FinishReason.FINISH_REASON_ERROR:
      return "FINISH_REASON_ERROR";
    case FinishReason.FINISH_REASON_CONTEXT_LENGTH_EXCEEDED:
      return "FINISH_REASON_CONTEXT_LENGTH_EXCEEDED";
    case FinishReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ArtifactType {
  ARTIFACT_TYPE_UNSPECIFIED = 0,
  ARTIFACT_TYPE_IMAGE = 1,
  ARTIFACT_TYPE_AUDIO = 2,
  ARTIFACT_TYPE_VIDEO = 3,
  ARTIFACT_TYPE_DOCUMENT = 4,
  ARTIFACT_TYPE_CODE = 5,
  UNRECOGNIZED = -1,
}

export function artifactTypeFromJSON(object: any): ArtifactType {
  switch (object) {
    case 0:
    case "ARTIFACT_TYPE_UNSPECIFIED":
      return ArtifactType.ARTIFACT_TYPE_UNSPECIFIED;
    case 1:
    case "ARTIFACT_TYPE_IMAGE":
      return ArtifactType.ARTIFACT_TYPE_IMAGE;
    case 2:
    case "ARTIFACT_TYPE_AUDIO":
      return ArtifactType.ARTIFACT_TYPE_AUDIO;
    case 3:
    case "ARTIFACT_TYPE_VIDEO":
      return ArtifactType.ARTIFACT_TYPE_VIDEO;
    case 4:
    case "ARTIFACT_TYPE_DOCUMENT":
      return ArtifactType.ARTIFACT_TYPE_DOCUMENT;
    case 5:
    case "ARTIFACT_TYPE_CODE":
      return ArtifactType.ARTIFACT_TYPE_CODE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ArtifactType.UNRECOGNIZED;
  }
}

export function artifactTypeToJSON(object: ArtifactType): string {
  switch (object) {
    case ArtifactType.ARTIFACT_TYPE_UNSPECIFIED:
      return "ARTIFACT_TYPE_UNSPECIFIED";
    case ArtifactType.ARTIFACT_TYPE_IMAGE:
      return "ARTIFACT_TYPE_IMAGE";
    case ArtifactType.ARTIFACT_TYPE_AUDIO:
      return "ARTIFACT_TYPE_AUDIO";
    case ArtifactType.ARTIFACT_TYPE_VIDEO:
      return "ARTIFACT_TYPE_VIDEO";
    case ArtifactType.ARTIFACT_TYPE_DOCUMENT:
      return "ARTIFACT_TYPE_DOCUMENT";
    case ArtifactType.ARTIFACT_TYPE_CODE:
      return "ARTIFACT_TYPE_CODE";
    case ArtifactType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** =========================== REQUEST =========================== */
export interface LLMChatRequest {
  requestId: string;
  userId: string;
  sessionId: string;
  prompt: ContentBlock[];
  /** NEW: Context management hints */
  contextOptions:
    | ContextOptions
    | undefined;
  /** NEW: Model preferences (optional override) */
  modelPrefs: ModelPreferences | undefined;
}

export interface ContextOptions {
  /** Max tokens to use from history */
  maxHistoryTokens: number;
  /** Whether to use RAG retrieval */
  enableRetrieval: boolean;
  /** Max chunks to retrieve from vector DB */
  maxRetrievalChunks: number;
  /** Whether to wait for file processing (vs return immediately) */
  waitForFiles: boolean;
}

export interface ModelPreferences {
  /** Force a specific model (e.g., "llama3-70b", "llava-1.6") */
  modelOverride: string;
  /** Routing strategy: "auto", "fast", "quality" */
  routingStrategy: string;
}

/** =========================== INPUT =========================== */
export interface ContentBlock {
  mimeType: string;
  text?:
    | string
    | undefined;
  /** S3/presigned URL */
  uri?: string | undefined;
  metadata: { [key: string]: string };
  /** NEW: For large files, client can provide processing hints */
  hints: ProcessingHints | undefined;
}

export interface ContentBlock_MetadataEntry {
  key: string;
  value: string;
}

export interface ProcessingHints {
  /** For videos: which segments to focus on (seconds) */
  timeRanges: TimeRange[];
  /** For documents: specific pages */
  pageNumbers: number[];
  /** Priority level (higher = process faster) */
  priority: number;
}

export interface TimeRange {
  startSeconds: number;
  endSeconds: number;
}

/** =========================== STREAMING EVENTS =========================== */
export interface LLMChatResponse {
  requestId: string;
  sequence: number;
  start?: StreamStart | undefined;
  modelSelected?:
    | ModelSelected
    | undefined;
  /** NEW: File processing status updates */
  fileStatus?: FileProcessingStatus | undefined;
  token?: TextToken | undefined;
  message?: TextMessage | undefined;
  artifactStarted?: ArtifactStarted | undefined;
  artifactChunk?: ArtifactChunk | undefined;
  artifactCompleted?: ArtifactCompleted | undefined;
  toolCall?: ToolCall | undefined;
  toolResult?: ToolResult | undefined;
  citation?: Citation | undefined;
  summary?: ExecutionSummary | undefined;
  end?: StreamEnd | undefined;
  error?: ErrorEvent | undefined;
}

/** NEW: Real-time file processing updates */
export interface FileProcessingStatus {
  fileId: string;
  filename: string;
  status: FileStatus;
  progressPercent: number;
  /** e.g., "Extracting keyframes..." */
  message: string;
}

/** =========================== SUMMARY =========================== */
export interface ExecutionSummary {
  modelUsage: ModelUsage[];
  totalInputTokens: number;
  totalOutputTokens: number;
  totalTokens: number;
  currency: string;
  estimatedCost: number;
  /** NEW: Processing stats */
  filesProcessed: number;
  retrievalChunksUsed: number;
}

export interface ModelUsage {
  modelName: string;
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  metadata: { [key: string]: string };
}

export interface ModelUsage_MetadataEntry {
  key: string;
  value: string;
}

/** =========================== STREAM LIFECYCLE =========================== */
export interface StreamStart {
  timestamp: string;
}

export interface StreamEnd {
  timestamp: string;
  finishReason: FinishReason;
}

/** =========================== MODEL ROUTING =========================== */
export interface ModelSelected {
  modelName: string;
  parameters: { [key: string]: string };
  /** e.g., "complex query with images" */
  routingReason: string;
}

export interface ModelSelected_ParametersEntry {
  key: string;
  value: string;
}

/** =========================== TEXT OUTPUT =========================== */
export interface TextToken {
  text: string;
}

export interface TextMessage {
  text: string;
}

/** =========================== ARTIFACTS =========================== */
export interface ArtifactStarted {
  artifactId: string;
  type: ArtifactType;
  mimeType: string;
}

export interface ArtifactChunk {
  artifactId: string;
  inlineBytes?: Buffer | undefined;
  uri?: string | undefined;
}

export interface ArtifactCompleted {
  artifactId: string;
  finalUri: string;
  metadata: { [key: string]: string };
}

export interface ArtifactCompleted_MetadataEntry {
  key: string;
  value: string;
}

/** =========================== TOOLS =========================== */
export interface ToolCall {
  toolName: string;
  callId: string;
  inputJson: string;
}

export interface ToolResult {
  callId: string;
  outputJson: string;
  success: boolean;
}

/** =========================== RETRIEVAL / CITATIONS =========================== */
export interface Citation {
  citationId: string;
  sourceUri: string;
  excerpt: string;
  /** NEW */
  relevanceScore: number;
}

/** =========================== FILE STATUS CHECK =========================== */
export interface CheckFileStatusRequest {
  fileIds: string[];
}

export interface CheckFileStatusResponse {
  files: FileInfo[];
}

export interface FileInfo {
  fileId: string;
  status: FileStatus;
  s3Uri: string;
  sizeBytes: number;
  mimeType: string;
  processingProgress: number;
}

/** =========================== CHAT HISTORY =========================== */
export interface ChatHistoryRequest {
  userId: string;
  sessionId: string;
  maxMessages: number;
}

export interface ChatHistoryResponse {
  messages: ChatMessage[];
}

export interface ChatMessage {
  messageId: string;
  /** "user" or "assistant" */
  role: string;
  content: string;
  timestamp: string;
  fileIds: string[];
}

/** =========================== ERRORS =========================== */
export interface ErrorEvent {
  code: string;
  message: string;
  recoverable: boolean;
  /** NEW: structured error info */
  details: { [key: string]: string };
}

export interface ErrorEvent_DetailsEntry {
  key: string;
  value: string;
}

function createBaseLLMChatRequest(): LLMChatRequest {
  return { requestId: "", userId: "", sessionId: "", prompt: [], contextOptions: undefined, modelPrefs: undefined };
}

export const LLMChatRequest: MessageFns<LLMChatRequest> = {
  encode(message: LLMChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.sessionId !== "") {
      writer.uint32(26).string(message.sessionId);
    }
    for (const v of message.prompt) {
      ContentBlock.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.contextOptions !== undefined) {
      ContextOptions.encode(message.contextOptions, writer.uint32(42).fork()).join();
    }
    if (message.modelPrefs !== undefined) {
      ModelPreferences.encode(message.modelPrefs, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LLMChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prompt.push(ContentBlock.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contextOptions = ContextOptions.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modelPrefs = ModelPreferences.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMChatRequest {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      prompt: globalThis.Array.isArray(object?.prompt) ? object.prompt.map((e: any) => ContentBlock.fromJSON(e)) : [],
      contextOptions: isSet(object.contextOptions)
        ? ContextOptions.fromJSON(object.contextOptions)
        : isSet(object.context_options)
        ? ContextOptions.fromJSON(object.context_options)
        : undefined,
      modelPrefs: isSet(object.modelPrefs)
        ? ModelPreferences.fromJSON(object.modelPrefs)
        : isSet(object.model_prefs)
        ? ModelPreferences.fromJSON(object.model_prefs)
        : undefined,
    };
  },

  toJSON(message: LLMChatRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.prompt?.length) {
      obj.prompt = message.prompt.map((e) => ContentBlock.toJSON(e));
    }
    if (message.contextOptions !== undefined) {
      obj.contextOptions = ContextOptions.toJSON(message.contextOptions);
    }
    if (message.modelPrefs !== undefined) {
      obj.modelPrefs = ModelPreferences.toJSON(message.modelPrefs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMChatRequest>, I>>(base?: I): LLMChatRequest {
    return LLMChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMChatRequest>, I>>(object: I): LLMChatRequest {
    const message = createBaseLLMChatRequest();
    message.requestId = object.requestId ?? "";
    message.userId = object.userId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.prompt = object.prompt?.map((e) => ContentBlock.fromPartial(e)) || [];
    message.contextOptions = (object.contextOptions !== undefined && object.contextOptions !== null)
      ? ContextOptions.fromPartial(object.contextOptions)
      : undefined;
    message.modelPrefs = (object.modelPrefs !== undefined && object.modelPrefs !== null)
      ? ModelPreferences.fromPartial(object.modelPrefs)
      : undefined;
    return message;
  },
};

function createBaseContextOptions(): ContextOptions {
  return { maxHistoryTokens: 0, enableRetrieval: false, maxRetrievalChunks: 0, waitForFiles: false };
}

export const ContextOptions: MessageFns<ContextOptions> = {
  encode(message: ContextOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxHistoryTokens !== 0) {
      writer.uint32(8).int32(message.maxHistoryTokens);
    }
    if (message.enableRetrieval !== false) {
      writer.uint32(16).bool(message.enableRetrieval);
    }
    if (message.maxRetrievalChunks !== 0) {
      writer.uint32(24).int32(message.maxRetrievalChunks);
    }
    if (message.waitForFiles !== false) {
      writer.uint32(32).bool(message.waitForFiles);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContextOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContextOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxHistoryTokens = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enableRetrieval = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxRetrievalChunks = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.waitForFiles = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContextOptions {
    return {
      maxHistoryTokens: isSet(object.maxHistoryTokens)
        ? globalThis.Number(object.maxHistoryTokens)
        : isSet(object.max_history_tokens)
        ? globalThis.Number(object.max_history_tokens)
        : 0,
      enableRetrieval: isSet(object.enableRetrieval)
        ? globalThis.Boolean(object.enableRetrieval)
        : isSet(object.enable_retrieval)
        ? globalThis.Boolean(object.enable_retrieval)
        : false,
      maxRetrievalChunks: isSet(object.maxRetrievalChunks)
        ? globalThis.Number(object.maxRetrievalChunks)
        : isSet(object.max_retrieval_chunks)
        ? globalThis.Number(object.max_retrieval_chunks)
        : 0,
      waitForFiles: isSet(object.waitForFiles)
        ? globalThis.Boolean(object.waitForFiles)
        : isSet(object.wait_for_files)
        ? globalThis.Boolean(object.wait_for_files)
        : false,
    };
  },

  toJSON(message: ContextOptions): unknown {
    const obj: any = {};
    if (message.maxHistoryTokens !== 0) {
      obj.maxHistoryTokens = Math.round(message.maxHistoryTokens);
    }
    if (message.enableRetrieval !== false) {
      obj.enableRetrieval = message.enableRetrieval;
    }
    if (message.maxRetrievalChunks !== 0) {
      obj.maxRetrievalChunks = Math.round(message.maxRetrievalChunks);
    }
    if (message.waitForFiles !== false) {
      obj.waitForFiles = message.waitForFiles;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContextOptions>, I>>(base?: I): ContextOptions {
    return ContextOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContextOptions>, I>>(object: I): ContextOptions {
    const message = createBaseContextOptions();
    message.maxHistoryTokens = object.maxHistoryTokens ?? 0;
    message.enableRetrieval = object.enableRetrieval ?? false;
    message.maxRetrievalChunks = object.maxRetrievalChunks ?? 0;
    message.waitForFiles = object.waitForFiles ?? false;
    return message;
  },
};

function createBaseModelPreferences(): ModelPreferences {
  return { modelOverride: "", routingStrategy: "" };
}

export const ModelPreferences: MessageFns<ModelPreferences> = {
  encode(message: ModelPreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modelOverride !== "") {
      writer.uint32(10).string(message.modelOverride);
    }
    if (message.routingStrategy !== "") {
      writer.uint32(18).string(message.routingStrategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelPreferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelPreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelOverride = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.routingStrategy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelPreferences {
    return {
      modelOverride: isSet(object.modelOverride)
        ? globalThis.String(object.modelOverride)
        : isSet(object.model_override)
        ? globalThis.String(object.model_override)
        : "",
      routingStrategy: isSet(object.routingStrategy)
        ? globalThis.String(object.routingStrategy)
        : isSet(object.routing_strategy)
        ? globalThis.String(object.routing_strategy)
        : "",
    };
  },

  toJSON(message: ModelPreferences): unknown {
    const obj: any = {};
    if (message.modelOverride !== "") {
      obj.modelOverride = message.modelOverride;
    }
    if (message.routingStrategy !== "") {
      obj.routingStrategy = message.routingStrategy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelPreferences>, I>>(base?: I): ModelPreferences {
    return ModelPreferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelPreferences>, I>>(object: I): ModelPreferences {
    const message = createBaseModelPreferences();
    message.modelOverride = object.modelOverride ?? "";
    message.routingStrategy = object.routingStrategy ?? "";
    return message;
  },
};

function createBaseContentBlock(): ContentBlock {
  return { mimeType: "", text: undefined, uri: undefined, metadata: {}, hints: undefined };
}

export const ContentBlock: MessageFns<ContentBlock> = {
  encode(message: ContentBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mimeType !== "") {
      writer.uint32(10).string(message.mimeType);
    }
    if (message.text !== undefined) {
      writer.uint32(18).string(message.text);
    }
    if (message.uri !== undefined) {
      writer.uint32(26).string(message.uri);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      ContentBlock_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.hints !== undefined) {
      ProcessingHints.encode(message.hints, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ContentBlock_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hints = ProcessingHints.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentBlock {
    return {
      mimeType: isSet(object.mimeType)
        ? globalThis.String(object.mimeType)
        : isSet(object.mime_type)
        ? globalThis.String(object.mime_type)
        : "",
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      hints: isSet(object.hints) ? ProcessingHints.fromJSON(object.hints) : undefined,
    };
  },

  toJSON(message: ContentBlock): unknown {
    const obj: any = {};
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.hints !== undefined) {
      obj.hints = ProcessingHints.toJSON(message.hints);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentBlock>, I>>(base?: I): ContentBlock {
    return ContentBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentBlock>, I>>(object: I): ContentBlock {
    const message = createBaseContentBlock();
    message.mimeType = object.mimeType ?? "";
    message.text = object.text ?? undefined;
    message.uri = object.uri ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.hints = (object.hints !== undefined && object.hints !== null)
      ? ProcessingHints.fromPartial(object.hints)
      : undefined;
    return message;
  },
};

function createBaseContentBlock_MetadataEntry(): ContentBlock_MetadataEntry {
  return { key: "", value: "" };
}

export const ContentBlock_MetadataEntry: MessageFns<ContentBlock_MetadataEntry> = {
  encode(message: ContentBlock_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentBlock_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentBlock_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentBlock_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ContentBlock_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentBlock_MetadataEntry>, I>>(base?: I): ContentBlock_MetadataEntry {
    return ContentBlock_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentBlock_MetadataEntry>, I>>(object: I): ContentBlock_MetadataEntry {
    const message = createBaseContentBlock_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProcessingHints(): ProcessingHints {
  return { timeRanges: [], pageNumbers: [], priority: 0 };
}

export const ProcessingHints: MessageFns<ProcessingHints> = {
  encode(message: ProcessingHints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.timeRanges) {
      TimeRange.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.pageNumbers) {
      writer.int32(v);
    }
    writer.join();
    if (message.priority !== 0) {
      writer.uint32(24).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingHints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingHints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeRanges.push(TimeRange.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.pageNumbers.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.pageNumbers.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingHints {
    return {
      timeRanges: globalThis.Array.isArray(object?.timeRanges)
        ? object.timeRanges.map((e: any) => TimeRange.fromJSON(e))
        : globalThis.Array.isArray(object?.time_ranges)
        ? object.time_ranges.map((e: any) => TimeRange.fromJSON(e))
        : [],
      pageNumbers: globalThis.Array.isArray(object?.pageNumbers)
        ? object.pageNumbers.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.page_numbers)
        ? object.page_numbers.map((e: any) => globalThis.Number(e))
        : [],
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
    };
  },

  toJSON(message: ProcessingHints): unknown {
    const obj: any = {};
    if (message.timeRanges?.length) {
      obj.timeRanges = message.timeRanges.map((e) => TimeRange.toJSON(e));
    }
    if (message.pageNumbers?.length) {
      obj.pageNumbers = message.pageNumbers.map((e) => Math.round(e));
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingHints>, I>>(base?: I): ProcessingHints {
    return ProcessingHints.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingHints>, I>>(object: I): ProcessingHints {
    const message = createBaseProcessingHints();
    message.timeRanges = object.timeRanges?.map((e) => TimeRange.fromPartial(e)) || [];
    message.pageNumbers = object.pageNumbers?.map((e) => e) || [];
    message.priority = object.priority ?? 0;
    return message;
  },
};

function createBaseTimeRange(): TimeRange {
  return { startSeconds: 0, endSeconds: 0 };
}

export const TimeRange: MessageFns<TimeRange> = {
  encode(message: TimeRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startSeconds !== 0) {
      writer.uint32(13).float(message.startSeconds);
    }
    if (message.endSeconds !== 0) {
      writer.uint32(21).float(message.endSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.startSeconds = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.endSeconds = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeRange {
    return {
      startSeconds: isSet(object.startSeconds)
        ? globalThis.Number(object.startSeconds)
        : isSet(object.start_seconds)
        ? globalThis.Number(object.start_seconds)
        : 0,
      endSeconds: isSet(object.endSeconds)
        ? globalThis.Number(object.endSeconds)
        : isSet(object.end_seconds)
        ? globalThis.Number(object.end_seconds)
        : 0,
    };
  },

  toJSON(message: TimeRange): unknown {
    const obj: any = {};
    if (message.startSeconds !== 0) {
      obj.startSeconds = message.startSeconds;
    }
    if (message.endSeconds !== 0) {
      obj.endSeconds = message.endSeconds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeRange>, I>>(base?: I): TimeRange {
    return TimeRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeRange>, I>>(object: I): TimeRange {
    const message = createBaseTimeRange();
    message.startSeconds = object.startSeconds ?? 0;
    message.endSeconds = object.endSeconds ?? 0;
    return message;
  },
};

function createBaseLLMChatResponse(): LLMChatResponse {
  return {
    requestId: "",
    sequence: 0,
    start: undefined,
    modelSelected: undefined,
    fileStatus: undefined,
    token: undefined,
    message: undefined,
    artifactStarted: undefined,
    artifactChunk: undefined,
    artifactCompleted: undefined,
    toolCall: undefined,
    toolResult: undefined,
    citation: undefined,
    summary: undefined,
    end: undefined,
    error: undefined,
  };
}

export const LLMChatResponse: MessageFns<LLMChatResponse> = {
  encode(message: LLMChatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.sequence !== 0) {
      writer.uint32(16).int64(message.sequence);
    }
    if (message.start !== undefined) {
      StreamStart.encode(message.start, writer.uint32(82).fork()).join();
    }
    if (message.modelSelected !== undefined) {
      ModelSelected.encode(message.modelSelected, writer.uint32(90).fork()).join();
    }
    if (message.fileStatus !== undefined) {
      FileProcessingStatus.encode(message.fileStatus, writer.uint32(98).fork()).join();
    }
    if (message.token !== undefined) {
      TextToken.encode(message.token, writer.uint32(162).fork()).join();
    }
    if (message.message !== undefined) {
      TextMessage.encode(message.message, writer.uint32(170).fork()).join();
    }
    if (message.artifactStarted !== undefined) {
      ArtifactStarted.encode(message.artifactStarted, writer.uint32(242).fork()).join();
    }
    if (message.artifactChunk !== undefined) {
      ArtifactChunk.encode(message.artifactChunk, writer.uint32(250).fork()).join();
    }
    if (message.artifactCompleted !== undefined) {
      ArtifactCompleted.encode(message.artifactCompleted, writer.uint32(258).fork()).join();
    }
    if (message.toolCall !== undefined) {
      ToolCall.encode(message.toolCall, writer.uint32(322).fork()).join();
    }
    if (message.toolResult !== undefined) {
      ToolResult.encode(message.toolResult, writer.uint32(330).fork()).join();
    }
    if (message.citation !== undefined) {
      Citation.encode(message.citation, writer.uint32(402).fork()).join();
    }
    if (message.summary !== undefined) {
      ExecutionSummary.encode(message.summary, writer.uint32(642).fork()).join();
    }
    if (message.end !== undefined) {
      StreamEnd.encode(message.end, writer.uint32(722).fork()).join();
    }
    if (message.error !== undefined) {
      ErrorEvent.encode(message.error, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LLMChatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMChatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sequence = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.start = StreamStart.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.modelSelected = ModelSelected.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.fileStatus = FileProcessingStatus.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.token = TextToken.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.message = TextMessage.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.artifactStarted = ArtifactStarted.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.artifactChunk = ArtifactChunk.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.artifactCompleted = ArtifactCompleted.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.toolCall = ToolCall.decode(reader, reader.uint32());
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.toolResult = ToolResult.decode(reader, reader.uint32());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.citation = Citation.decode(reader, reader.uint32());
          continue;
        }
        case 80: {
          if (tag !== 642) {
            break;
          }

          message.summary = ExecutionSummary.decode(reader, reader.uint32());
          continue;
        }
        case 90: {
          if (tag !== 722) {
            break;
          }

          message.end = StreamEnd.decode(reader, reader.uint32());
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.error = ErrorEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMChatResponse {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      start: isSet(object.start) ? StreamStart.fromJSON(object.start) : undefined,
      modelSelected: isSet(object.modelSelected)
        ? ModelSelected.fromJSON(object.modelSelected)
        : isSet(object.model_selected)
        ? ModelSelected.fromJSON(object.model_selected)
        : undefined,
      fileStatus: isSet(object.fileStatus)
        ? FileProcessingStatus.fromJSON(object.fileStatus)
        : isSet(object.file_status)
        ? FileProcessingStatus.fromJSON(object.file_status)
        : undefined,
      token: isSet(object.token) ? TextToken.fromJSON(object.token) : undefined,
      message: isSet(object.message) ? TextMessage.fromJSON(object.message) : undefined,
      artifactStarted: isSet(object.artifactStarted)
        ? ArtifactStarted.fromJSON(object.artifactStarted)
        : isSet(object.artifact_started)
        ? ArtifactStarted.fromJSON(object.artifact_started)
        : undefined,
      artifactChunk: isSet(object.artifactChunk)
        ? ArtifactChunk.fromJSON(object.artifactChunk)
        : isSet(object.artifact_chunk)
        ? ArtifactChunk.fromJSON(object.artifact_chunk)
        : undefined,
      artifactCompleted: isSet(object.artifactCompleted)
        ? ArtifactCompleted.fromJSON(object.artifactCompleted)
        : isSet(object.artifact_completed)
        ? ArtifactCompleted.fromJSON(object.artifact_completed)
        : undefined,
      toolCall: isSet(object.toolCall)
        ? ToolCall.fromJSON(object.toolCall)
        : isSet(object.tool_call)
        ? ToolCall.fromJSON(object.tool_call)
        : undefined,
      toolResult: isSet(object.toolResult)
        ? ToolResult.fromJSON(object.toolResult)
        : isSet(object.tool_result)
        ? ToolResult.fromJSON(object.tool_result)
        : undefined,
      citation: isSet(object.citation) ? Citation.fromJSON(object.citation) : undefined,
      summary: isSet(object.summary) ? ExecutionSummary.fromJSON(object.summary) : undefined,
      end: isSet(object.end) ? StreamEnd.fromJSON(object.end) : undefined,
      error: isSet(object.error) ? ErrorEvent.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: LLMChatResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.start !== undefined) {
      obj.start = StreamStart.toJSON(message.start);
    }
    if (message.modelSelected !== undefined) {
      obj.modelSelected = ModelSelected.toJSON(message.modelSelected);
    }
    if (message.fileStatus !== undefined) {
      obj.fileStatus = FileProcessingStatus.toJSON(message.fileStatus);
    }
    if (message.token !== undefined) {
      obj.token = TextToken.toJSON(message.token);
    }
    if (message.message !== undefined) {
      obj.message = TextMessage.toJSON(message.message);
    }
    if (message.artifactStarted !== undefined) {
      obj.artifactStarted = ArtifactStarted.toJSON(message.artifactStarted);
    }
    if (message.artifactChunk !== undefined) {
      obj.artifactChunk = ArtifactChunk.toJSON(message.artifactChunk);
    }
    if (message.artifactCompleted !== undefined) {
      obj.artifactCompleted = ArtifactCompleted.toJSON(message.artifactCompleted);
    }
    if (message.toolCall !== undefined) {
      obj.toolCall = ToolCall.toJSON(message.toolCall);
    }
    if (message.toolResult !== undefined) {
      obj.toolResult = ToolResult.toJSON(message.toolResult);
    }
    if (message.citation !== undefined) {
      obj.citation = Citation.toJSON(message.citation);
    }
    if (message.summary !== undefined) {
      obj.summary = ExecutionSummary.toJSON(message.summary);
    }
    if (message.end !== undefined) {
      obj.end = StreamEnd.toJSON(message.end);
    }
    if (message.error !== undefined) {
      obj.error = ErrorEvent.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMChatResponse>, I>>(base?: I): LLMChatResponse {
    return LLMChatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMChatResponse>, I>>(object: I): LLMChatResponse {
    const message = createBaseLLMChatResponse();
    message.requestId = object.requestId ?? "";
    message.sequence = object.sequence ?? 0;
    message.start = (object.start !== undefined && object.start !== null)
      ? StreamStart.fromPartial(object.start)
      : undefined;
    message.modelSelected = (object.modelSelected !== undefined && object.modelSelected !== null)
      ? ModelSelected.fromPartial(object.modelSelected)
      : undefined;
    message.fileStatus = (object.fileStatus !== undefined && object.fileStatus !== null)
      ? FileProcessingStatus.fromPartial(object.fileStatus)
      : undefined;
    message.token = (object.token !== undefined && object.token !== null)
      ? TextToken.fromPartial(object.token)
      : undefined;
    message.message = (object.message !== undefined && object.message !== null)
      ? TextMessage.fromPartial(object.message)
      : undefined;
    message.artifactStarted = (object.artifactStarted !== undefined && object.artifactStarted !== null)
      ? ArtifactStarted.fromPartial(object.artifactStarted)
      : undefined;
    message.artifactChunk = (object.artifactChunk !== undefined && object.artifactChunk !== null)
      ? ArtifactChunk.fromPartial(object.artifactChunk)
      : undefined;
    message.artifactCompleted = (object.artifactCompleted !== undefined && object.artifactCompleted !== null)
      ? ArtifactCompleted.fromPartial(object.artifactCompleted)
      : undefined;
    message.toolCall = (object.toolCall !== undefined && object.toolCall !== null)
      ? ToolCall.fromPartial(object.toolCall)
      : undefined;
    message.toolResult = (object.toolResult !== undefined && object.toolResult !== null)
      ? ToolResult.fromPartial(object.toolResult)
      : undefined;
    message.citation = (object.citation !== undefined && object.citation !== null)
      ? Citation.fromPartial(object.citation)
      : undefined;
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? ExecutionSummary.fromPartial(object.summary)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? StreamEnd.fromPartial(object.end) : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorEvent.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseFileProcessingStatus(): FileProcessingStatus {
  return { fileId: "", filename: "", status: 0, progressPercent: 0, message: "" };
}

export const FileProcessingStatus: MessageFns<FileProcessingStatus> = {
  encode(message: FileProcessingStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    if (message.filename !== "") {
      writer.uint32(18).string(message.filename);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.progressPercent !== 0) {
      writer.uint32(37).float(message.progressPercent);
    }
    if (message.message !== "") {
      writer.uint32(42).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileProcessingStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileProcessingStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.progressPercent = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileProcessingStatus {
    return {
      fileId: isSet(object.fileId)
        ? globalThis.String(object.fileId)
        : isSet(object.file_id)
        ? globalThis.String(object.file_id)
        : "",
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      status: isSet(object.status) ? fileStatusFromJSON(object.status) : 0,
      progressPercent: isSet(object.progressPercent)
        ? globalThis.Number(object.progressPercent)
        : isSet(object.progress_percent)
        ? globalThis.Number(object.progress_percent)
        : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: FileProcessingStatus): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.status !== 0) {
      obj.status = fileStatusToJSON(message.status);
    }
    if (message.progressPercent !== 0) {
      obj.progressPercent = message.progressPercent;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileProcessingStatus>, I>>(base?: I): FileProcessingStatus {
    return FileProcessingStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileProcessingStatus>, I>>(object: I): FileProcessingStatus {
    const message = createBaseFileProcessingStatus();
    message.fileId = object.fileId ?? "";
    message.filename = object.filename ?? "";
    message.status = object.status ?? 0;
    message.progressPercent = object.progressPercent ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseExecutionSummary(): ExecutionSummary {
  return {
    modelUsage: [],
    totalInputTokens: 0,
    totalOutputTokens: 0,
    totalTokens: 0,
    currency: "",
    estimatedCost: 0,
    filesProcessed: 0,
    retrievalChunksUsed: 0,
  };
}

export const ExecutionSummary: MessageFns<ExecutionSummary> = {
  encode(message: ExecutionSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.modelUsage) {
      ModelUsage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalInputTokens !== 0) {
      writer.uint32(16).int64(message.totalInputTokens);
    }
    if (message.totalOutputTokens !== 0) {
      writer.uint32(24).int64(message.totalOutputTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(32).int64(message.totalTokens);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.estimatedCost !== 0) {
      writer.uint32(49).double(message.estimatedCost);
    }
    if (message.filesProcessed !== 0) {
      writer.uint32(56).int64(message.filesProcessed);
    }
    if (message.retrievalChunksUsed !== 0) {
      writer.uint32(64).int64(message.retrievalChunksUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelUsage.push(ModelUsage.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalInputTokens = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalOutputTokens = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalTokens = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.estimatedCost = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.filesProcessed = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.retrievalChunksUsed = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionSummary {
    return {
      modelUsage: globalThis.Array.isArray(object?.modelUsage)
        ? object.modelUsage.map((e: any) => ModelUsage.fromJSON(e))
        : globalThis.Array.isArray(object?.model_usage)
        ? object.model_usage.map((e: any) => ModelUsage.fromJSON(e))
        : [],
      totalInputTokens: isSet(object.totalInputTokens)
        ? globalThis.Number(object.totalInputTokens)
        : isSet(object.total_input_tokens)
        ? globalThis.Number(object.total_input_tokens)
        : 0,
      totalOutputTokens: isSet(object.totalOutputTokens)
        ? globalThis.Number(object.totalOutputTokens)
        : isSet(object.total_output_tokens)
        ? globalThis.Number(object.total_output_tokens)
        : 0,
      totalTokens: isSet(object.totalTokens)
        ? globalThis.Number(object.totalTokens)
        : isSet(object.total_tokens)
        ? globalThis.Number(object.total_tokens)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      estimatedCost: isSet(object.estimatedCost)
        ? globalThis.Number(object.estimatedCost)
        : isSet(object.estimated_cost)
        ? globalThis.Number(object.estimated_cost)
        : 0,
      filesProcessed: isSet(object.filesProcessed)
        ? globalThis.Number(object.filesProcessed)
        : isSet(object.files_processed)
        ? globalThis.Number(object.files_processed)
        : 0,
      retrievalChunksUsed: isSet(object.retrievalChunksUsed)
        ? globalThis.Number(object.retrievalChunksUsed)
        : isSet(object.retrieval_chunks_used)
        ? globalThis.Number(object.retrieval_chunks_used)
        : 0,
    };
  },

  toJSON(message: ExecutionSummary): unknown {
    const obj: any = {};
    if (message.modelUsage?.length) {
      obj.modelUsage = message.modelUsage.map((e) => ModelUsage.toJSON(e));
    }
    if (message.totalInputTokens !== 0) {
      obj.totalInputTokens = Math.round(message.totalInputTokens);
    }
    if (message.totalOutputTokens !== 0) {
      obj.totalOutputTokens = Math.round(message.totalOutputTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.estimatedCost !== 0) {
      obj.estimatedCost = message.estimatedCost;
    }
    if (message.filesProcessed !== 0) {
      obj.filesProcessed = Math.round(message.filesProcessed);
    }
    if (message.retrievalChunksUsed !== 0) {
      obj.retrievalChunksUsed = Math.round(message.retrievalChunksUsed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionSummary>, I>>(base?: I): ExecutionSummary {
    return ExecutionSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionSummary>, I>>(object: I): ExecutionSummary {
    const message = createBaseExecutionSummary();
    message.modelUsage = object.modelUsage?.map((e) => ModelUsage.fromPartial(e)) || [];
    message.totalInputTokens = object.totalInputTokens ?? 0;
    message.totalOutputTokens = object.totalOutputTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    message.currency = object.currency ?? "";
    message.estimatedCost = object.estimatedCost ?? 0;
    message.filesProcessed = object.filesProcessed ?? 0;
    message.retrievalChunksUsed = object.retrievalChunksUsed ?? 0;
    return message;
  },
};

function createBaseModelUsage(): ModelUsage {
  return { modelName: "", inputTokens: 0, outputTokens: 0, totalTokens: 0, metadata: {} };
}

export const ModelUsage: MessageFns<ModelUsage> = {
  encode(message: ModelUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modelName !== "") {
      writer.uint32(10).string(message.modelName);
    }
    if (message.inputTokens !== 0) {
      writer.uint32(16).int64(message.inputTokens);
    }
    if (message.outputTokens !== 0) {
      writer.uint32(24).int64(message.outputTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(32).int64(message.totalTokens);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      ModelUsage_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inputTokens = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.outputTokens = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalTokens = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = ModelUsage_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelUsage {
    return {
      modelName: isSet(object.modelName)
        ? globalThis.String(object.modelName)
        : isSet(object.model_name)
        ? globalThis.String(object.model_name)
        : "",
      inputTokens: isSet(object.inputTokens)
        ? globalThis.Number(object.inputTokens)
        : isSet(object.input_tokens)
        ? globalThis.Number(object.input_tokens)
        : 0,
      outputTokens: isSet(object.outputTokens)
        ? globalThis.Number(object.outputTokens)
        : isSet(object.output_tokens)
        ? globalThis.Number(object.output_tokens)
        : 0,
      totalTokens: isSet(object.totalTokens)
        ? globalThis.Number(object.totalTokens)
        : isSet(object.total_tokens)
        ? globalThis.Number(object.total_tokens)
        : 0,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ModelUsage): unknown {
    const obj: any = {};
    if (message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    if (message.inputTokens !== 0) {
      obj.inputTokens = Math.round(message.inputTokens);
    }
    if (message.outputTokens !== 0) {
      obj.outputTokens = Math.round(message.outputTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelUsage>, I>>(base?: I): ModelUsage {
    return ModelUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelUsage>, I>>(object: I): ModelUsage {
    const message = createBaseModelUsage();
    message.modelName = object.modelName ?? "";
    message.inputTokens = object.inputTokens ?? 0;
    message.outputTokens = object.outputTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseModelUsage_MetadataEntry(): ModelUsage_MetadataEntry {
  return { key: "", value: "" };
}

export const ModelUsage_MetadataEntry: MessageFns<ModelUsage_MetadataEntry> = {
  encode(message: ModelUsage_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelUsage_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelUsage_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelUsage_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ModelUsage_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelUsage_MetadataEntry>, I>>(base?: I): ModelUsage_MetadataEntry {
    return ModelUsage_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelUsage_MetadataEntry>, I>>(object: I): ModelUsage_MetadataEntry {
    const message = createBaseModelUsage_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStreamStart(): StreamStart {
  return { timestamp: "" };
}

export const StreamStart: MessageFns<StreamStart> = {
  encode(message: StreamStart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== "") {
      writer.uint32(10).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStart {
    return { timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "" };
  },

  toJSON(message: StreamStart): unknown {
    const obj: any = {};
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamStart>, I>>(base?: I): StreamStart {
    return StreamStart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamStart>, I>>(object: I): StreamStart {
    const message = createBaseStreamStart();
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseStreamEnd(): StreamEnd {
  return { timestamp: "", finishReason: 0 };
}

export const StreamEnd: MessageFns<StreamEnd> = {
  encode(message: StreamEnd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== "") {
      writer.uint32(10).string(message.timestamp);
    }
    if (message.finishReason !== 0) {
      writer.uint32(16).int32(message.finishReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamEnd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamEnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.finishReason = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamEnd {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      finishReason: isSet(object.finishReason)
        ? finishReasonFromJSON(object.finishReason)
        : isSet(object.finish_reason)
        ? finishReasonFromJSON(object.finish_reason)
        : 0,
    };
  },

  toJSON(message: StreamEnd): unknown {
    const obj: any = {};
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.finishReason !== 0) {
      obj.finishReason = finishReasonToJSON(message.finishReason);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamEnd>, I>>(base?: I): StreamEnd {
    return StreamEnd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamEnd>, I>>(object: I): StreamEnd {
    const message = createBaseStreamEnd();
    message.timestamp = object.timestamp ?? "";
    message.finishReason = object.finishReason ?? 0;
    return message;
  },
};

function createBaseModelSelected(): ModelSelected {
  return { modelName: "", parameters: {}, routingReason: "" };
}

export const ModelSelected: MessageFns<ModelSelected> = {
  encode(message: ModelSelected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modelName !== "") {
      writer.uint32(10).string(message.modelName);
    }
    globalThis.Object.entries(message.parameters).forEach(([key, value]: [string, string]) => {
      ModelSelected_ParametersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.routingReason !== "") {
      writer.uint32(26).string(message.routingReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelSelected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelSelected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ModelSelected_ParametersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.parameters[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.routingReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelSelected {
    return {
      modelName: isSet(object.modelName)
        ? globalThis.String(object.modelName)
        : isSet(object.model_name)
        ? globalThis.String(object.model_name)
        : "",
      parameters: isObject(object.parameters)
        ? (globalThis.Object.entries(object.parameters) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      routingReason: isSet(object.routingReason)
        ? globalThis.String(object.routingReason)
        : isSet(object.routing_reason)
        ? globalThis.String(object.routing_reason)
        : "",
    };
  },

  toJSON(message: ModelSelected): unknown {
    const obj: any = {};
    if (message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    if (message.parameters) {
      const entries = globalThis.Object.entries(message.parameters) as [string, string][];
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    if (message.routingReason !== "") {
      obj.routingReason = message.routingReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelSelected>, I>>(base?: I): ModelSelected {
    return ModelSelected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelSelected>, I>>(object: I): ModelSelected {
    const message = createBaseModelSelected();
    message.modelName = object.modelName ?? "";
    message.parameters = (globalThis.Object.entries(object.parameters ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.routingReason = object.routingReason ?? "";
    return message;
  },
};

function createBaseModelSelected_ParametersEntry(): ModelSelected_ParametersEntry {
  return { key: "", value: "" };
}

export const ModelSelected_ParametersEntry: MessageFns<ModelSelected_ParametersEntry> = {
  encode(message: ModelSelected_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelSelected_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelSelected_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelSelected_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ModelSelected_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelSelected_ParametersEntry>, I>>(base?: I): ModelSelected_ParametersEntry {
    return ModelSelected_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelSelected_ParametersEntry>, I>>(
    object: I,
  ): ModelSelected_ParametersEntry {
    const message = createBaseModelSelected_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTextToken(): TextToken {
  return { text: "" };
}

export const TextToken: MessageFns<TextToken> = {
  encode(message: TextToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextToken {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: TextToken): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextToken>, I>>(base?: I): TextToken {
    return TextToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextToken>, I>>(object: I): TextToken {
    const message = createBaseTextToken();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseTextMessage(): TextMessage {
  return { text: "" };
}

export const TextMessage: MessageFns<TextMessage> = {
  encode(message: TextMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextMessage {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: TextMessage): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextMessage>, I>>(base?: I): TextMessage {
    return TextMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextMessage>, I>>(object: I): TextMessage {
    const message = createBaseTextMessage();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseArtifactStarted(): ArtifactStarted {
  return { artifactId: "", type: 0, mimeType: "" };
}

export const ArtifactStarted: MessageFns<ArtifactStarted> = {
  encode(message: ArtifactStarted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArtifactStarted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactStarted {
    return {
      artifactId: isSet(object.artifactId)
        ? globalThis.String(object.artifactId)
        : isSet(object.artifact_id)
        ? globalThis.String(object.artifact_id)
        : "",
      type: isSet(object.type) ? artifactTypeFromJSON(object.type) : 0,
      mimeType: isSet(object.mimeType)
        ? globalThis.String(object.mimeType)
        : isSet(object.mime_type)
        ? globalThis.String(object.mime_type)
        : "",
    };
  },

  toJSON(message: ArtifactStarted): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    if (message.type !== 0) {
      obj.type = artifactTypeToJSON(message.type);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactStarted>, I>>(base?: I): ArtifactStarted {
    return ArtifactStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactStarted>, I>>(object: I): ArtifactStarted {
    const message = createBaseArtifactStarted();
    message.artifactId = object.artifactId ?? "";
    message.type = object.type ?? 0;
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseArtifactChunk(): ArtifactChunk {
  return { artifactId: "", inlineBytes: undefined, uri: undefined };
}

export const ArtifactChunk: MessageFns<ArtifactChunk> = {
  encode(message: ArtifactChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    if (message.inlineBytes !== undefined) {
      writer.uint32(18).bytes(message.inlineBytes);
    }
    if (message.uri !== undefined) {
      writer.uint32(26).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArtifactChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inlineBytes = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactChunk {
    return {
      artifactId: isSet(object.artifactId)
        ? globalThis.String(object.artifactId)
        : isSet(object.artifact_id)
        ? globalThis.String(object.artifact_id)
        : "",
      inlineBytes: isSet(object.inlineBytes)
        ? Buffer.from(bytesFromBase64(object.inlineBytes))
        : isSet(object.inline_bytes)
        ? Buffer.from(bytesFromBase64(object.inline_bytes))
        : undefined,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
    };
  },

  toJSON(message: ArtifactChunk): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    if (message.inlineBytes !== undefined) {
      obj.inlineBytes = base64FromBytes(message.inlineBytes);
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactChunk>, I>>(base?: I): ArtifactChunk {
    return ArtifactChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactChunk>, I>>(object: I): ArtifactChunk {
    const message = createBaseArtifactChunk();
    message.artifactId = object.artifactId ?? "";
    message.inlineBytes = object.inlineBytes ?? undefined;
    message.uri = object.uri ?? undefined;
    return message;
  },
};

function createBaseArtifactCompleted(): ArtifactCompleted {
  return { artifactId: "", finalUri: "", metadata: {} };
}

export const ArtifactCompleted: MessageFns<ArtifactCompleted> = {
  encode(message: ArtifactCompleted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    if (message.finalUri !== "") {
      writer.uint32(18).string(message.finalUri);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      ArtifactCompleted_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArtifactCompleted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.finalUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ArtifactCompleted_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactCompleted {
    return {
      artifactId: isSet(object.artifactId)
        ? globalThis.String(object.artifactId)
        : isSet(object.artifact_id)
        ? globalThis.String(object.artifact_id)
        : "",
      finalUri: isSet(object.finalUri)
        ? globalThis.String(object.finalUri)
        : isSet(object.final_uri)
        ? globalThis.String(object.final_uri)
        : "",
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ArtifactCompleted): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    if (message.finalUri !== "") {
      obj.finalUri = message.finalUri;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactCompleted>, I>>(base?: I): ArtifactCompleted {
    return ArtifactCompleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactCompleted>, I>>(object: I): ArtifactCompleted {
    const message = createBaseArtifactCompleted();
    message.artifactId = object.artifactId ?? "";
    message.finalUri = object.finalUri ?? "";
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseArtifactCompleted_MetadataEntry(): ArtifactCompleted_MetadataEntry {
  return { key: "", value: "" };
}

export const ArtifactCompleted_MetadataEntry: MessageFns<ArtifactCompleted_MetadataEntry> = {
  encode(message: ArtifactCompleted_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArtifactCompleted_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifactCompleted_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtifactCompleted_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ArtifactCompleted_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArtifactCompleted_MetadataEntry>, I>>(base?: I): ArtifactCompleted_MetadataEntry {
    return ArtifactCompleted_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArtifactCompleted_MetadataEntry>, I>>(
    object: I,
  ): ArtifactCompleted_MetadataEntry {
    const message = createBaseArtifactCompleted_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseToolCall(): ToolCall {
  return { toolName: "", callId: "", inputJson: "" };
}

export const ToolCall: MessageFns<ToolCall> = {
  encode(message: ToolCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolName !== "") {
      writer.uint32(10).string(message.toolName);
    }
    if (message.callId !== "") {
      writer.uint32(18).string(message.callId);
    }
    if (message.inputJson !== "") {
      writer.uint32(26).string(message.inputJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.callId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCall {
    return {
      toolName: isSet(object.toolName)
        ? globalThis.String(object.toolName)
        : isSet(object.tool_name)
        ? globalThis.String(object.tool_name)
        : "",
      callId: isSet(object.callId)
        ? globalThis.String(object.callId)
        : isSet(object.call_id)
        ? globalThis.String(object.call_id)
        : "",
      inputJson: isSet(object.inputJson)
        ? globalThis.String(object.inputJson)
        : isSet(object.input_json)
        ? globalThis.String(object.input_json)
        : "",
    };
  },

  toJSON(message: ToolCall): unknown {
    const obj: any = {};
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.callId !== "") {
      obj.callId = message.callId;
    }
    if (message.inputJson !== "") {
      obj.inputJson = message.inputJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCall>, I>>(base?: I): ToolCall {
    return ToolCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCall>, I>>(object: I): ToolCall {
    const message = createBaseToolCall();
    message.toolName = object.toolName ?? "";
    message.callId = object.callId ?? "";
    message.inputJson = object.inputJson ?? "";
    return message;
  },
};

function createBaseToolResult(): ToolResult {
  return { callId: "", outputJson: "", success: false };
}

export const ToolResult: MessageFns<ToolResult> = {
  encode(message: ToolResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callId !== "") {
      writer.uint32(10).string(message.callId);
    }
    if (message.outputJson !== "") {
      writer.uint32(18).string(message.outputJson);
    }
    if (message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.callId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputJson = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolResult {
    return {
      callId: isSet(object.callId)
        ? globalThis.String(object.callId)
        : isSet(object.call_id)
        ? globalThis.String(object.call_id)
        : "",
      outputJson: isSet(object.outputJson)
        ? globalThis.String(object.outputJson)
        : isSet(object.output_json)
        ? globalThis.String(object.output_json)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: ToolResult): unknown {
    const obj: any = {};
    if (message.callId !== "") {
      obj.callId = message.callId;
    }
    if (message.outputJson !== "") {
      obj.outputJson = message.outputJson;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolResult>, I>>(base?: I): ToolResult {
    return ToolResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolResult>, I>>(object: I): ToolResult {
    const message = createBaseToolResult();
    message.callId = object.callId ?? "";
    message.outputJson = object.outputJson ?? "";
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCitation(): Citation {
  return { citationId: "", sourceUri: "", excerpt: "", relevanceScore: 0 };
}

export const Citation: MessageFns<Citation> = {
  encode(message: Citation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.citationId !== "") {
      writer.uint32(10).string(message.citationId);
    }
    if (message.sourceUri !== "") {
      writer.uint32(18).string(message.sourceUri);
    }
    if (message.excerpt !== "") {
      writer.uint32(26).string(message.excerpt);
    }
    if (message.relevanceScore !== 0) {
      writer.uint32(37).float(message.relevanceScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Citation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCitation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.citationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.excerpt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.relevanceScore = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Citation {
    return {
      citationId: isSet(object.citationId)
        ? globalThis.String(object.citationId)
        : isSet(object.citation_id)
        ? globalThis.String(object.citation_id)
        : "",
      sourceUri: isSet(object.sourceUri)
        ? globalThis.String(object.sourceUri)
        : isSet(object.source_uri)
        ? globalThis.String(object.source_uri)
        : "",
      excerpt: isSet(object.excerpt) ? globalThis.String(object.excerpt) : "",
      relevanceScore: isSet(object.relevanceScore)
        ? globalThis.Number(object.relevanceScore)
        : isSet(object.relevance_score)
        ? globalThis.Number(object.relevance_score)
        : 0,
    };
  },

  toJSON(message: Citation): unknown {
    const obj: any = {};
    if (message.citationId !== "") {
      obj.citationId = message.citationId;
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    if (message.excerpt !== "") {
      obj.excerpt = message.excerpt;
    }
    if (message.relevanceScore !== 0) {
      obj.relevanceScore = message.relevanceScore;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Citation>, I>>(base?: I): Citation {
    return Citation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Citation>, I>>(object: I): Citation {
    const message = createBaseCitation();
    message.citationId = object.citationId ?? "";
    message.sourceUri = object.sourceUri ?? "";
    message.excerpt = object.excerpt ?? "";
    message.relevanceScore = object.relevanceScore ?? 0;
    return message;
  },
};

function createBaseCheckFileStatusRequest(): CheckFileStatusRequest {
  return { fileIds: [] };
}

export const CheckFileStatusRequest: MessageFns<CheckFileStatusRequest> = {
  encode(message: CheckFileStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fileIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckFileStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckFileStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckFileStatusRequest {
    return {
      fileIds: globalThis.Array.isArray(object?.fileIds)
        ? object.fileIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.file_ids)
        ? object.file_ids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CheckFileStatusRequest): unknown {
    const obj: any = {};
    if (message.fileIds?.length) {
      obj.fileIds = message.fileIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckFileStatusRequest>, I>>(base?: I): CheckFileStatusRequest {
    return CheckFileStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckFileStatusRequest>, I>>(object: I): CheckFileStatusRequest {
    const message = createBaseCheckFileStatusRequest();
    message.fileIds = object.fileIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCheckFileStatusResponse(): CheckFileStatusResponse {
  return { files: [] };
}

export const CheckFileStatusResponse: MessageFns<CheckFileStatusResponse> = {
  encode(message: CheckFileStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      FileInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckFileStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckFileStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(FileInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckFileStatusResponse {
    return { files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => FileInfo.fromJSON(e)) : [] };
  },

  toJSON(message: CheckFileStatusResponse): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => FileInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckFileStatusResponse>, I>>(base?: I): CheckFileStatusResponse {
    return CheckFileStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckFileStatusResponse>, I>>(object: I): CheckFileStatusResponse {
    const message = createBaseCheckFileStatusResponse();
    message.files = object.files?.map((e) => FileInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFileInfo(): FileInfo {
  return { fileId: "", status: 0, s3Uri: "", sizeBytes: 0, mimeType: "", processingProgress: 0 };
}

export const FileInfo: MessageFns<FileInfo> = {
  encode(message: FileInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.s3Uri !== "") {
      writer.uint32(26).string(message.s3Uri);
    }
    if (message.sizeBytes !== 0) {
      writer.uint32(32).int64(message.sizeBytes);
    }
    if (message.mimeType !== "") {
      writer.uint32(42).string(message.mimeType);
    }
    if (message.processingProgress !== 0) {
      writer.uint32(53).float(message.processingProgress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.s3Uri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sizeBytes = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.processingProgress = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileInfo {
    return {
      fileId: isSet(object.fileId)
        ? globalThis.String(object.fileId)
        : isSet(object.file_id)
        ? globalThis.String(object.file_id)
        : "",
      status: isSet(object.status) ? fileStatusFromJSON(object.status) : 0,
      s3Uri: isSet(object.s3Uri)
        ? globalThis.String(object.s3Uri)
        : isSet(object.s3_uri)
        ? globalThis.String(object.s3_uri)
        : "",
      sizeBytes: isSet(object.sizeBytes)
        ? globalThis.Number(object.sizeBytes)
        : isSet(object.size_bytes)
        ? globalThis.Number(object.size_bytes)
        : 0,
      mimeType: isSet(object.mimeType)
        ? globalThis.String(object.mimeType)
        : isSet(object.mime_type)
        ? globalThis.String(object.mime_type)
        : "",
      processingProgress: isSet(object.processingProgress)
        ? globalThis.Number(object.processingProgress)
        : isSet(object.processing_progress)
        ? globalThis.Number(object.processing_progress)
        : 0,
    };
  },

  toJSON(message: FileInfo): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.status !== 0) {
      obj.status = fileStatusToJSON(message.status);
    }
    if (message.s3Uri !== "") {
      obj.s3Uri = message.s3Uri;
    }
    if (message.sizeBytes !== 0) {
      obj.sizeBytes = Math.round(message.sizeBytes);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.processingProgress !== 0) {
      obj.processingProgress = message.processingProgress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileInfo>, I>>(base?: I): FileInfo {
    return FileInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileInfo>, I>>(object: I): FileInfo {
    const message = createBaseFileInfo();
    message.fileId = object.fileId ?? "";
    message.status = object.status ?? 0;
    message.s3Uri = object.s3Uri ?? "";
    message.sizeBytes = object.sizeBytes ?? 0;
    message.mimeType = object.mimeType ?? "";
    message.processingProgress = object.processingProgress ?? 0;
    return message;
  },
};

function createBaseChatHistoryRequest(): ChatHistoryRequest {
  return { userId: "", sessionId: "", maxMessages: 0 };
}

export const ChatHistoryRequest: MessageFns<ChatHistoryRequest> = {
  encode(message: ChatHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.maxMessages !== 0) {
      writer.uint32(24).int32(message.maxMessages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxMessages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatHistoryRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      maxMessages: isSet(object.maxMessages)
        ? globalThis.Number(object.maxMessages)
        : isSet(object.max_messages)
        ? globalThis.Number(object.max_messages)
        : 0,
    };
  },

  toJSON(message: ChatHistoryRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.maxMessages !== 0) {
      obj.maxMessages = Math.round(message.maxMessages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatHistoryRequest>, I>>(base?: I): ChatHistoryRequest {
    return ChatHistoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatHistoryRequest>, I>>(object: I): ChatHistoryRequest {
    const message = createBaseChatHistoryRequest();
    message.userId = object.userId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.maxMessages = object.maxMessages ?? 0;
    return message;
  },
};

function createBaseChatHistoryResponse(): ChatHistoryResponse {
  return { messages: [] };
}

export const ChatHistoryResponse: MessageFns<ChatHistoryResponse> = {
  encode(message: ChatHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      ChatMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(ChatMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatHistoryResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChatMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChatHistoryResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ChatMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatHistoryResponse>, I>>(base?: I): ChatHistoryResponse {
    return ChatHistoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatHistoryResponse>, I>>(object: I): ChatHistoryResponse {
    const message = createBaseChatHistoryResponse();
    message.messages = object.messages?.map((e) => ChatMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChatMessage(): ChatMessage {
  return { messageId: "", role: "", content: "", timestamp: "", fileIds: [] };
}

export const ChatMessage: MessageFns<ChatMessage> = {
  encode(message: ChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    for (const v of message.fileIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage {
    return {
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : isSet(object.message_id)
        ? globalThis.String(object.message_id)
        : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      fileIds: globalThis.Array.isArray(object?.fileIds)
        ? object.fileIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.file_ids)
        ? object.file_ids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ChatMessage): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.fileIds?.length) {
      obj.fileIds = message.fileIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage>, I>>(base?: I): ChatMessage {
    return ChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage>, I>>(object: I): ChatMessage {
    const message = createBaseChatMessage();
    message.messageId = object.messageId ?? "";
    message.role = object.role ?? "";
    message.content = object.content ?? "";
    message.timestamp = object.timestamp ?? "";
    message.fileIds = object.fileIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseErrorEvent(): ErrorEvent {
  return { code: "", message: "", recoverable: false, details: {} };
}

export const ErrorEvent: MessageFns<ErrorEvent> = {
  encode(message: ErrorEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.recoverable !== false) {
      writer.uint32(24).bool(message.recoverable);
    }
    globalThis.Object.entries(message.details).forEach(([key, value]: [string, string]) => {
      ErrorEvent_DetailsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.recoverable = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ErrorEvent_DetailsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.details[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorEvent {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      recoverable: isSet(object.recoverable) ? globalThis.Boolean(object.recoverable) : false,
      details: isObject(object.details)
        ? (globalThis.Object.entries(object.details) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ErrorEvent): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.recoverable !== false) {
      obj.recoverable = message.recoverable;
    }
    if (message.details) {
      const entries = globalThis.Object.entries(message.details) as [string, string][];
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorEvent>, I>>(base?: I): ErrorEvent {
    return ErrorEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorEvent>, I>>(object: I): ErrorEvent {
    const message = createBaseErrorEvent();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.recoverable = object.recoverable ?? false;
    message.details = (globalThis.Object.entries(object.details ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseErrorEvent_DetailsEntry(): ErrorEvent_DetailsEntry {
  return { key: "", value: "" };
}

export const ErrorEvent_DetailsEntry: MessageFns<ErrorEvent_DetailsEntry> = {
  encode(message: ErrorEvent_DetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorEvent_DetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorEvent_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorEvent_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ErrorEvent_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorEvent_DetailsEntry>, I>>(base?: I): ErrorEvent_DetailsEntry {
    return ErrorEvent_DetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorEvent_DetailsEntry>, I>>(object: I): ErrorEvent_DetailsEntry {
    const message = createBaseErrorEvent_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

/** =========================== TOP-LEVEL SERVICE =========================== */
export type LLMServiceService = typeof LLMServiceService;
export const LLMServiceService = {
  /** Buf enforces a strict convention: rpc MethodName(MethodNameRequest) returns (MethodNameResponse) */
  llmChat: {
    path: "/llm.v1.LLMService/LLMChat",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: LLMChatRequest): Buffer => Buffer.from(LLMChatRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LLMChatRequest => LLMChatRequest.decode(value),
    responseSerialize: (value: LLMChatResponse): Buffer => Buffer.from(LLMChatResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LLMChatResponse => LLMChatResponse.decode(value),
  },
  /** NEW: Check if uploaded files are ready for querying */
  checkFileStatus: {
    path: "/llm.v1.LLMService/CheckFileStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckFileStatusRequest): Buffer =>
      Buffer.from(CheckFileStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckFileStatusRequest => CheckFileStatusRequest.decode(value),
    responseSerialize: (value: CheckFileStatusResponse): Buffer =>
      Buffer.from(CheckFileStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckFileStatusResponse => CheckFileStatusResponse.decode(value),
  },
} as const;

export interface LLMServiceServer extends UntypedServiceImplementation {
  /** Buf enforces a strict convention: rpc MethodName(MethodNameRequest) returns (MethodNameResponse) */
  llmChat: handleServerStreamingCall<LLMChatRequest, LLMChatResponse>;
  /** NEW: Check if uploaded files are ready for querying */
  checkFileStatus: handleUnaryCall<CheckFileStatusRequest, CheckFileStatusResponse>;
}

export interface LLMServiceClient extends Client {
  /** Buf enforces a strict convention: rpc MethodName(MethodNameRequest) returns (MethodNameResponse) */
  llmChat(request: LLMChatRequest, options?: Partial<CallOptions>): ClientReadableStream<LLMChatResponse>;
  llmChat(
    request: LLMChatRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<LLMChatResponse>;
  /** NEW: Check if uploaded files are ready for querying */
  checkFileStatus(
    request: CheckFileStatusRequest,
    callback: (error: ServiceError | null, response: CheckFileStatusResponse) => void,
  ): ClientUnaryCall;
  checkFileStatus(
    request: CheckFileStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckFileStatusResponse) => void,
  ): ClientUnaryCall;
  checkFileStatus(
    request: CheckFileStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckFileStatusResponse) => void,
  ): ClientUnaryCall;
}

export const LLMServiceClient = makeGenericClientConstructor(LLMServiceService, "llm.v1.LLMService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): LLMServiceClient;
  service: typeof LLMServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
